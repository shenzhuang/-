1. 说说你对数据,变量, 内存的理解, 以及它们之间的关系
	* 数据: 在内存中可读的, 可传递的保存了特定信息的'东东'
	* 变量: 在程序运行过程中它的值是允许改变的量
	* 内存: 内存条==>集成电路==>通电==>暂时存储正在运行的程序及其产生的数据==>程序停止==>占用的空间自动释放
	* 关系:
		* 内存是容器, 用来存储不同数据
		* 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据
2. 说说你对jS对象的理解
	* 什么是对象?
	  * 多个数据(属性)的集合
	  * 用来保存多个数据(属性)的容器
	* 属性组成:
	  * 属性名 : 字符串(标识)
	  * 属性值 : 任意类型
	* 属性的分类:
	  * 一般 : 属性值不是function  描述对象的状态
	  * 方法 : 属性值为function的属性  描述对象的行为
	* 特别的对象
	  * 数组: 属性名是0,1,2,3之类的索引
	  * 函数: 可以执行的
	* 如何操作内部属性(方法)
	  * .属性名
	  * ['属性名']: 属性名有特殊字符/属性名是一个变量
3. 说说你对函数的理解
	* 什么是函数?
	  * 用来实现特定功能的, n条语句的封装体
	* 使用函数有什么好处?
	  * 提高复用性
	  * 便于阅读交流
	* 函数也是对象
	* 函数的3种不同角色
	* 函数中的this
	* 匿名函数自调用
4. 说说你对回调函数的理解
	* 什么函数才是回调函数?
	  * 你定义的
	  * 你没有调用
	  * 但它最终执行了(在一定条件下或某个时刻)
	* 常用的回调函数
	  * dom事件回调函数
	  * 定时器回调函数
	  * ajax请求回调函数
5. 说说你对原型和原型链的理解
	* 所有函数都有一个特别的属性:
	  * `prototype` : 显式原型属性
	* 所有实例对象都有一个特别的属性:
	  * `__proto__` : 隐式原型属性
	* 原型链
	  * 所有的实例对象都有__proto__属性, 它指向的就是原型对象
	  * 这样通过__proto__属性就形成了一个链的结构---->原型链
	  * 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找
6. 说说你对闭包的理解
	* 理解:
	  * 当嵌套的内部函数引用了外部函数的变量时就产生了闭包
	  * 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性
	* 作用:
	  * 延长局部变量的生命周期
	  * 让函数外部能操作内部的局部变量
7. 编码实现组合模式创建对象
	```
	function Person(name, age) {
		this.name = name;
		this.age = age;
	}
	Person.prototype.setName = function(name){this.name=name;};
	new Person('tom', 12);
	```
8. 编码通过组合模式实现继承
	```
	function Parent(xxx){this.xxx = xxx}
	Parent.prototype.test = function(){};
	function Child(xxx,yyy){
	  Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
	}
	Child.prototype = new Parent(); //得到test()
	var child = new Child(); //child.xxx为'a', 也有test()
	```
9. 说说你对事件机制的理解
	* 所有代码分类
		* 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
		* 回调执行代码: 处理回调逻辑
	* js引擎执行代码的基本流程: 
		* 初始化代码===>回调代码
	* 模型的2个重要组成部分:
		* 事件管理模块
		* 回调队列
	* 模型的运转流程
		* 执行初始化代码, 将事件回调函数交给对应模块管理
		* 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
		* 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行
10. 说说你平时都如何使用Chrome的开发者工具的
	* 开发者面板的组成(常用的)
	  * Elements
	  * Console
	  * Sources
	  * Network
	  * Application
	* JS的debug调试
	  * 启动调试:
	    * 添加断点
	    * 刷新页面/操作页面-->程序执行到断点处悬停
	  * 开始调试
	    * 单步跳过
	    * 跳入
	    * 跳出
	    * 执行完当前断点, 进入下一个断点
	    * 查看数据
	    * 移除断点